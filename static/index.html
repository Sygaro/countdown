<!doctype html>
<html lang="no">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Countdown Â· Visning</title>
    <link rel="stylesheet" href="/static/css/ui.css" />
  </head>
  <body class="center fill">
    <button id="btn_fullscreen" class="fs-btn" title="Fullskjerm">â›¶ Fullskjerm</button>

    <!-- Nedtelling -->
    <div id="view_countdown" class="center fill" style="flex-direction: column; gap: 2vh; display: none">
      <div id="msgs_above" class="muted" style="display: none; text-align: center">
        <div id="msg_primary_above"></div>
        <div id="msg_secondary_above"></div>
      </div>

      <div id="digits" class="big">00:00</div>

      <div id="msgs_below" class="muted" style="display: none; text-align: center">
        <div id="msg_primary_below"></div>
        <div id="msg_secondary_below"></div>
      </div>
    </div>

    <!-- Klokke-modus -->
    <div id="view_clock" class="center fill" style="display: none">
      <div id="clock_time" style="font-weight: 800"></div>
      <div id="clock_msgs" aria-hidden="false">
        <div id="clock_msg_primary"></div>
        <div id="clock_msg_secondary"></div>
      </div>
    </div>

    <script>
      (function () {
        const $ = (s) => document.querySelector(s);
        const state = {
          cfg: null,
          tick: null,
          lastCfgRev: 0,
          clockTimer: null,
        };
        const isPreview = new URLSearchParams(location.search).get("preview") === "1";
        if (isPreview) {
          document.documentElement.classList.add("is-preview");
        }

        let lastActivityTs = Date.now();

        const fmtMMSS = (ms) => {
          const neg = ms < 0 ? "-" : "";
          ms = Math.abs(ms);
          const t = Math.floor(ms / 1000),
            m = Math.floor(t / 60),
            s = t % 60;
          return `${neg}${m}:${String(s).padStart(2, "0")}`;
        };
        const fmtHMS = (ms) => {
          const neg = ms < 0 ? "-" : "";
          ms = Math.abs(ms);
          const t = Math.floor(ms / 1000),
            h = Math.floor(t / 3600),
            r = t % 3600,
            m = Math.floor(r / 60),
            s = r % 60;
          const pad = (n) => String(n).padStart(2, "0");
          return `${neg}${h}:${pad(m)}:${pad(s)}`;
        };
        const hex2rgb = (h) => {
          const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h || "");
          if (!m) return "0,0,0";
          return `${parseInt(m[1], 16)},${parseInt(m[2], 16)},${parseInt(m[3], 16)}`;
        };

        function applyDigitsSize() {
          const vw = Number(state.cfg?.theme?.digits?.size_vw ?? 14);
          $("#digits").style.fontSize = `${vw}vw`;
        }
        function applyMessageStyles() {
          const p = state.cfg?.theme?.messages?.primary || {};
          const s = state.cfg?.theme?.messages?.secondary || {};

          // Hjelper som skriver vmin i stedet for rem
          const set = (sel, m) => {
            const el = document.querySelector(sel);
            if (!el) return;
            const size = Number(m.size_vmin ?? 6);
            el.style.fontSize = `${size}vmin`;
            el.style.fontWeight = String(Number(m.weight ?? 400));
            el.style.color = String(m.color ?? "#9aa4b2");
          };

          set("#msg_primary_above", p);
          set("#msg_secondary_above", s);
          set("#msg_primary_below", p);
          set("#msg_secondary_below", s);

          // primÃ¦r litt stÃ¸rre enn sekundÃ¦r
          set("#msg_primary_above", p, 2.0);
          set("#msg_secondary_above", s, 1.8);
          set("#msg_primary_below", p, 2.0);
          set("#msg_secondary_below", s, 1.8);
        }

        // --- dynamisk lag: keyframes + elementhÃ¥ndtering ---
        function ensureDynKeyframes() {
          if (document.getElementById("dynbg_keyframes")) return;
          const st = document.createElement("style");
          st.id = "dynbg_keyframes";
          st.textContent = `
@keyframes dynbg-rotate {
  0%   { transform: rotate(0deg) scale(1.02); }
  100% { transform: rotate(360deg) scale(1.02); }
}`;
          document.head.appendChild(st);
        }
        function getDynLayer() {
          return document.getElementById("dyn_bg_layer");
        }
        function ensureDynLayer() {
          let el = getDynLayer();
          if (!el) {
            el = document.createElement("div");
            el.id = "dyn_bg_layer";
            el.style.position = "fixed";
            el.style.inset = "-15%";
            el.style.zIndex = "0"; // bak overlays (som har 50)
            el.style.pointerEvents = "none";
            document.body.appendChild(el);
          }
          return el;
        }
        function removeDynLayer() {
          const el = getDynLayer();
          if (el && el.parentNode) el.parentNode.removeChild(el);
        }

        // --- HJELPERE ---
        function hexToRgba(hex, opacity) {
          const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec((hex || "").trim());
          if (!m) return `rgba(0,0,0,${Number(opacity || 0)})`;
          const r = parseInt(m[1], 16),
            g = parseInt(m[2], 16),
            b = parseInt(m[3], 16);
          const a = Math.max(0, Math.min(1, Number(opacity || 0)));
          return `rgba(${r},${g},${b},${a})`;
        }

        // --- NY: robust bakgrunn inkl. dynamic + base ---
        function applyThemeBackground(el, bg) {
          if (!el || !bg) return;

          // nullstill base pÃ¥ body
          el.style.background = "";
          el.style.backgroundColor = "";
          el.style.backgroundImage = "";
          el.style.backgroundRepeat = "";
          el.style.backgroundSize = "";
          el.style.backgroundPosition = "";

          const mode = (bg.mode || "solid").toLowerCase();

          // BASE-bygger (brukes ogsÃ¥ av dynamic)
          function applyBase() {
            const imgUrl = (bg?.image?.url || "").trim();
            if (imgUrl) {
              // IMAGE (med ev. tint)
              const fit = (bg?.image?.fit || "cover").toLowerCase();
              const tintC = bg?.image?.tint?.color || null;
              const tintO = Number(bg?.image?.tint?.opacity ?? 0);
              const layers = [];
              if (tintC && tintO > 0) {
                const rgba = hexToRgba(tintC, tintO);
                layers.push(`linear-gradient(${rgba}, ${rgba})`);
              }
              layers.push(`url("${imgUrl}")`);
              el.style.backgroundImage = layers.join(", ");
              el.style.backgroundRepeat = "no-repeat, no-repeat";
              el.style.backgroundSize =
                (layers.length === 2 ? "auto, " : "") + (fit === "contain" ? "contain" : "cover");
              el.style.backgroundPosition = "center center, center center";
              el.style.backgroundColor = "transparent";
              return "image";
            }

            // GRADIENT
            const from = bg?.gradient?.from || "#142033";
            const to = bg?.gradient?.to || "#0b0f14";
            const angle = Number(bg?.gradient?.angle_deg ?? 180);
            if (from && to) {
              el.style.backgroundImage = `linear-gradient(${angle}deg, ${from}, ${to})`;
              el.style.backgroundRepeat = "no-repeat";
              el.style.backgroundSize = "cover";
              el.style.backgroundPosition = "center center";
              el.style.backgroundColor = "transparent";
              return "gradient";
            }

            // SOLID (fallback)
            el.style.backgroundColor = bg?.solid?.color || "#0b0f14";
            el.style.backgroundImage = "none";
            return "solid";
          }

          if (mode === "solid") {
            removeDynLayer();
            el.style.backgroundColor = bg?.solid?.color || "#0b0f14";
            el.style.backgroundImage = "none";
            return;
          }

          if (mode === "gradient") {
            removeDynLayer();
            const from = bg?.gradient?.from || "#142033";
            const to = bg?.gradient?.to || "#0b0f14";
            const angle = Number(bg?.gradient?.angle_deg ?? 180);
            el.style.backgroundImage = `linear-gradient(${angle}deg, ${from}, ${to})`;
            el.style.backgroundColor = "transparent";
            el.style.backgroundRepeat = "no-repeat";
            el.style.backgroundSize = "cover";
            el.style.backgroundPosition = "center center";
            return;
          }

          if (mode === "image") {
            removeDynLayer();
            const url = (bg?.image?.url || "").trim();
            if (!url) {
              // ingen bilde â†’ bruk solid fallback
              el.style.backgroundColor = "#0b0f14";
              return;
            }
            const fit = (bg?.image?.fit || "cover").toLowerCase();
            const tintC = bg?.image?.tint?.color || null;
            const tintO = Number(bg?.image?.tint?.opacity ?? 0);

            const layers = [];
            if (tintC && tintO > 0) {
              const rgba = hexToRgba(tintC, tintO);
              layers.push(`linear-gradient(${rgba}, ${rgba})`);
            }
            layers.push(`url("${url}")`);
            el.style.backgroundImage = layers.join(", ");
            el.style.backgroundRepeat = "no-repeat, no-repeat";
            el.style.backgroundSize = (layers.length === 2 ? "auto, " : "") + (fit === "contain" ? "contain" : "cover");
            el.style.backgroundPosition = "center center, center center";
            el.style.backgroundColor = "transparent";
            return;
          }

          if (mode === "dynamic") {
            const dyn = bg?.dynamic || {};
            const basePref = (dyn.base_mode || "auto").toLowerCase();

            // 1) Base bakgrunn (image | gradient | solid | auto)
            function applyBase(pref) {
              const want = pref || "auto";
              const hasImg = !!(bg?.image?.url || "").trim();

              if (want === "image" || (want === "auto" && hasImg)) {
                const url = (bg?.image?.url || "").trim();
                const fit = (bg?.image?.fit || "cover").toLowerCase();
                const tintC = bg?.image?.tint?.color || null;
                const tintO = Number(bg?.image?.tint?.opacity ?? 0);
                const layers = [];
                if (tintC && tintO > 0) {
                  const rgba = hexToRgba(tintC, tintO);
                  layers.push(`linear-gradient(${rgba}, ${rgba})`);
                }
                if (url) layers.push(`url("${url}")`);
                if (layers.length) {
                  el.style.backgroundImage = layers.join(", ");
                  el.style.backgroundRepeat = "no-repeat, no-repeat";
                  el.style.backgroundSize =
                    (layers.length === 2 ? "auto, " : "") + (fit === "contain" ? "contain" : "cover");
                  el.style.backgroundPosition = "center center, center center";
                  el.style.backgroundColor = "transparent";
                  return;
                }
              }

              if (want === "gradient" || want === "auto") {
                const from = bg?.gradient?.from || "#142033";
                const to = bg?.gradient?.to || "#0b0f14";
                const angle = Number(bg?.gradient?.angle_deg ?? 180);
                el.style.backgroundImage = `linear-gradient(${angle}deg, ${from}, ${to})`;
                el.style.backgroundRepeat = "no-repeat";
                el.style.backgroundSize = "cover";
                el.style.backgroundPosition = "center center";
                el.style.backgroundColor = "transparent";
                return;
              }

              // solid:
              el.style.backgroundColor = bg?.solid?.color || "#0b0f14";
              el.style.backgroundImage = "none";
            }

            applyBase(basePref);

            // 2) Dynamisk lag oppÃ¥
            ensureDynKeyframes(); // eksisterende helper hos deg
            const layer = ensureDynLayer(); // eksisterende helper hos deg

            const from = dyn.from || "#16233a";
            const to = dyn.to || "#0e1a2f";
            const rotateS = Math.max(5, Math.min(600, Number(dyn.rotate_s ?? 60)));
            const blurPx = Math.max(0, Math.min(60, Number(dyn.blur_px ?? 18)));
            const opa = Math.max(0, Math.min(1, Number(dyn.opacity ?? 0.9)));

            layer.style.position = "fixed";
            layer.style.inset = "-24vmin";
            layer.style.zIndex = "0";
            layer.style.pointerEvents = "none";
            layer.style.filter = `blur(${blurPx}px)`;
            layer.style.opacity = String(opa);
            layer.style.animation = `dynbg-rotate ${rotateS}s linear infinite`;

            // store, viewport-relative radialer
            //layer.style.background =
            // `radial-gradient(72vmax 54vmax at 12% 10%, ${from} 0%, transparent 62%),` +
            // `radial-gradient(70vmax 52vmax at 88% 12%, ${to} 0%, transparent 64%),` +
            // `conic-gradient(from 220deg at 50% 50%, #0000 0%, #0000 100%)`;

            // alternative instillinger
            layer.style.background =
              `radial-gradient(72vmax 54vmax at 12% 10%, ${from} 0%, transparent 62%),` +
              `radial-gradient(70vmax 52vmax at 88% 12%, ${to} 0%, transparent 64%),` +
              `conic-gradient(from 220deg at 50% 50%, #0000 0%, #0000 100%)`;
            layer.style.inset = "0vmin";

            return; // ferdig med dynamic-grenen
          }
          // ukjent â†’ fallback solid
          removeDynLayer();
          el.style.backgroundColor = "#0b0f14";
        }
        function applyCountdown() {
          $("#view_clock").style.display = "none";
          const root = $("#view_countdown");
          root.style.display = "flex";
          // legg tema-bakgrunn pÃ¥ BODY
          applyThemeBackground(document.body, state.cfg?.theme?.background);
          // cleanup clock timer hvis aktiv
          if (state.clockTimer) {
            clearInterval(state.clockTimer);
            state.clockTimer = null;
          }
          $("#clock_time").style.display = "none";

          applyDigitsSize();
          applyMessageStyles();

          const c = state.cfg;
          const t = state.tick || {
            state: "idle",
            mode: "normal",
            signed_display_ms: 0,
            blink: false,
            target_hhmm: null,
          };

          const thresholdMs = (c.hms_threshold_minutes ?? 60) * 60 * 1000;
          const msActive = t.state === "countdown" || t.state === "overrun";
          const ms = msActive ? t.signed_display_ms : 0;

          const useHMS = Math.abs(ms) >= thresholdMs;
          const digits = $("#digits");
          digits.textContent = useHMS ? fmtHMS(ms) : fmtMMSS(ms);

          let color = c.color_normal;
          if (c.use_phase_colors) {
            if (t.state === "overrun" || t.signed_display_ms < 0) color = c.color_over || c.color_alert;
            else if (t.mode === "alert") color = c.color_alert;
            else if (t.mode === "warn") color = c.color_warn;
          }
          digits.style.color = color;
          digits.classList.toggle("blink", !!(c.use_blink && t.blink));

          const targetTextPrim =
            c.show_target_time && c.show_message_primary && c.target_time_after === "primary" && t.target_hhmm
              ? ` ${t.target_hhmm}`
              : "";
          const targetTextSec =
            c.show_target_time && c.show_message_secondary && c.target_time_after === "secondary" && t.target_hhmm
              ? ` ${t.target_hhmm}`
              : "";

          const prim = c.show_message_primary ? (c.message_primary || "") + targetTextPrim : "";
          const sec = c.show_message_secondary ? (c.message_secondary || "") + targetTextSec : "";

          const above = c.messages_position === "above";
          $("#msgs_above").style.display = above ? "block" : "none";
          $("#msgs_below").style.display = above ? "none" : "block";
          $("#msg_primary_above").textContent = above ? prim : "";
          $("#msg_secondary_above").textContent = above ? sec : "";
          $("#msg_primary_below").textContent = !above ? prim : "";
          $("#msg_secondary_below").textContent = !above ? sec : "";
          applyOverlays();
        }

        function applyClock() {
          // Skjul nedtelling
          const viewCountdown = $("#view_countdown");
          if (viewCountdown) viewCountdown.style.display = "none";

          // DOM
          const root = document.querySelector("#view_clock, #view_screen");
          const clkEl = document.querySelector("#clock_time, #screen_clock");
          const wrap = $("#clock_msgs");
          const elP = $("#clock_msg_primary");
          const elS = $("#clock_msg_secondary");
          if (!root || !clkEl || !wrap || !elP || !elS) return;

          root.style.display = "flex";

          // litt luft mot sidene
          const SIDE_INSET_VW = 5,
            TOP_BOTTOM_VH = 3;
          root.style.padding = `${TOP_BOTTOM_VH}vh ${SIDE_INSET_VW}vw`;

          // Bakgrunn
          applyThemeBackground(document.body, state.cfg?.theme?.background);

          // Klokkens plassering
          const clockPos = (state.cfg?.clock?.position || "center").toLowerCase();
          const posMap = {
            center: { ai: "center", jc: "center" },
            "top-left": { ai: "flex-start", jc: "flex-start" },
            "top-right": { ai: "flex-start", jc: "flex-end" },
            "bottom-left": { ai: "flex-end", jc: "flex-start" },
            "bottom-right": { ai: "flex-end", jc: "flex-end" },
            "top-center": { ai: "flex-start", jc: "center" },
            "bottom-center": { ai: "flex-end", jc: "center" },
          };
          const m = posMap[clockPos] || posMap.center;
          root.style.alignItems = m.ai;
          root.style.justifyContent = m.jc;

          // Klokkens typografi
          const clk = state.cfg?.clock || {};
          const sizeVmin = Number(clk.size_vmin ?? clk.size_vh ?? 12);
          const size = Math.max(6, Math.min(30, sizeVmin));
          clkEl.style.fontSize = `${size}vmin`;
          clkEl.style.fontWeight = "800";
          clkEl.style.display = "block";
          clkEl.style.color = clk.color || "#e6edf3";

          // Meldinger: vis KUN hvis use_clock_messages = true
          const useOwn = !!clk.use_clock_messages;
          if (!useOwn) {
            wrap.style.display = "none";
          } else {
            const msgP = (clk.message_primary || "").trim();
            const msgS = (clk.message_secondary || "").trim();
            const showP = !!msgP;
            const showS = !!msgS;

            // plassering rundt klokka
            const msgPos = clk.messages_position || "right"; // right|left|above|below
            const msgAlign = clk.messages_align || "center"; // start|center|end

            if (msgPos === "left" || msgPos === "right") {
              root.style.flexDirection = "row";
              wrap.style.flexDirection = "column";
              clkEl.style.order = msgPos === "left" ? 2 : 1;
              wrap.style.order = msgPos === "left" ? 1 : 2;

              // ðŸ‘‰ mer luft mellom klokke og tekst
              root.style.gap = "3vmin";
              // ekstra side-margin for wrap slik at det ikke â€œklistrerâ€ seg til klokka
              wrap.style.marginLeft = msgPos === "right" ? "2vmin" : "0";
              wrap.style.marginRight = msgPos === "left" ? "2vmin" : "0";
            } else {
              root.style.flexDirection = "column";
              clkEl.style.order = msgPos === "above" ? 2 : 1;
              wrap.style.order = msgPos === "above" ? 1 : 2;
              wrap.style.flexDirection = "column";

              // vertikal layout â€“ litt mindre gap
              root.style.gap = "1.25vmin";
              wrap.style.marginLeft = wrap.style.marginRight = "0";
            }

            wrap.style.display = showP || showS ? "flex" : "none";
            wrap.style.alignItems = { start: "flex-start", center: "center", end: "flex-end" }[msgAlign] || "center";
            wrap.style.textAlign = { start: "left", center: "center", end: "right" }[msgAlign] || "center";
            wrap.style.gap = "0.25rem";

            elP.style.display = showP ? "block" : "none";
            elS.style.display = showS ? "block" : "none";

            elP.textContent = msgP;
            elS.textContent = msgS;

            // âœ¨ Skaler tekst i vmin (pkt. 2)
            const themeMsg = state.cfg?.theme?.messages || {};
            const pTheme = themeMsg.primary || {};
            const sTheme = themeMsg.secondary || {};
            elP.style.fontSize = `${Number(pTheme.size_vmin ?? 6)}vmin`;
            elP.style.fontWeight = String(pTheme.weight ?? 600);
            elP.style.color = String(pTheme.color ?? "#9aa4b2");
            elS.style.fontSize = `${Number(sTheme.size_vmin ?? 4)}vmin`;
            elS.style.fontWeight = String(sTheme.weight ?? 400);
            elS.style.color = String(sTheme.color ?? "#9aa4b2");
          }

          // Timer
          if (state.clockTimer) {
            clearInterval(state.clockTimer);
            state.clockTimer = null;
          }
          const update = () => {
            const d = new Date();
            const HH = String(d.getHours()).padStart(2, "0");
            const MM = String(d.getMinutes()).padStart(2, "0");
            const SS = String(d.getSeconds()).padStart(2, "0");
            clkEl.textContent = clk.with_seconds ? `${HH}:${MM}:${SS}` : `${HH}:${MM}`;
          };
          update();
          state.clockTimer = setInterval(update, clk.with_seconds ? 1000 : 5000);
          applyOverlays();
        }

        async function fetchConfig() {
          const r = await fetch("/api/config");
          const js = await r.json();
          state.cfg = js.config;
          state.lastCfgRev = js.config._updated_at || 0;
          sendHeartbeat();
        }
        async function firstLoad() {
          await fetchConfig();
          const r = await fetch("/tick");
          state.tick = await r.json();
          render();
          sendHeartbeat();
        }
        async function pollTick() {
          const r = await fetch("/tick");
          const t = await r.json();
          state.tick = t;
          if ((t.cfg_rev || 0) !== state.lastCfgRev) await fetchConfig();
          render(true);
        }
        function applyOverlays() {
          const root = document.getElementById("overlays");
          if (!root) return;
          root.innerHTML = "";

          const list = Array.isArray(state.cfg?.overlays) ? state.cfg.overlays : [];
          if (!list.length) return;

          const mode = state.cfg?.mode || "daily";
          for (const o of list) {
            const vis =
              Array.isArray(o.visible_in) && o.visible_in.length
                ? o.visible_in
                : ["clock", "countdown", "daily", "once", "duration"];
            const show =
              (mode === "clock" && vis.includes("clock")) ||
              ((mode === "duration" || mode === "daily" || mode === "once") && vis.some((v) => v !== "clock"));
            if (!show) continue;

            if (o.type !== "image") continue;
            const url = (o.url || "").trim();
            if (!url) continue;

            const wrap = document.createElement("div");
            wrap.className = "overlay-wrap";
            wrap.style.position = "absolute";
            wrap.style.pointerEvents = "none";
            wrap.style.display = "inline-block";
            const z = Number.isFinite(o.z_index) ? o.z_index : 10;
            wrap.style.zIndex = String(z);

            const size = Math.max(2, Number(o.size_vmin ?? 12));
            wrap.style.width = `${size}vmin`;

            const pos = String(o.position || "top-right").toLowerCase();
            const offVW = Number(o.offset_vw ?? 2);
            const offVH = Number(o.offset_vh ?? 2);
            const set = (prop, value) => (wrap.style[prop] = value);
            const clr = (...props) => props.forEach((p) => (wrap.style[p] = ""));
            switch (pos) {
              case "top-left":
                set("top", `${offVH}vh`);
                set("left", `${offVW}vw`);
                clr("right", "bottom");
                wrap.style.transform = "none";
                break;
              case "top-right":
                set("top", `${offVH}vh`);
                set("right", `${offVW}vw`);
                clr("left", "bottom");
                wrap.style.transform = "none";
                break;
              case "bottom-left":
                set("bottom", `${offVH}vh`);
                set("left", `${offVW}vw`);
                clr("right", "top");
                wrap.style.transform = "none";
                break;
              case "bottom-center":
                set("bottom", `${offVH}vh`);
                set("left", "50%");
                clr("top", "right");
                wrap.style.transform = "translateX(-50%)";
                break;
              case "top-center":
                set("top", `${offVH}vh`);
                set("left", "50%");
                clr("bottom", "right");
                wrap.style.transform = "translateX(-50%)";
                break;
              case "center":
                set("top", "50%");
                set("left", "50%");
                clr("bottom", "right");
                wrap.style.transform = "translate(-50%,-50%)";
                break;
              case "center-left":
                set("top", "50%");
                set("left", `${offVW}vw`);
                clr("right", "bottom");
                wrap.style.transform = "translateY(-50%)";
                break;
              case "center-right":
                set("top", "50%");
                set("right", `${offVW}vw`);
                clr("left", "bottom");
                wrap.style.transform = "translateY(-50%)";
                break;
              case "bottom-right":
              default:
                set("bottom", `${offVH}vh`);
                set("right", `${offVW}vw`);
                clr("left", "top");
                wrap.style.transform = "none";
                break;
            }

            const img = document.createElement("img");
            img.src = url;
            img.alt = o.id || "overlay";
            img.className = "overlay-img";
            img.style.display = "block";
            img.style.width = "100%";
            img.style.height = "auto";
            img.style.opacity = String(Math.max(0, Math.min(1, Number(o.opacity ?? 1))));
            img.style.zIndex = String(z); // ligger under tint-laget (tint har zIndex z+1)
            img.style.position = "relative";
            wrap.appendChild(img);

            // tint (valgfritt) â€“ klipp til logoens alfakanal
            const tint = o.tint || {};
            const tintOpacity = Math.max(0, Math.min(1, Number(tint.opacity ?? 0)));
            if (tintOpacity > 0) {
              const tintColor = (tint.color || "#000000").trim();
              const blend = (tint.blend || "multiply").trim();

              const overlay = document.createElement("div");
              overlay.className = "overlay-tint";
              overlay.style.position = "absolute";
              overlay.style.inset = "0";
              overlay.style.backgroundColor = tintColor;
              overlay.style.opacity = String(tintOpacity);
              overlay.style.zIndex = String(z + 1);
              overlay.style.mixBlendMode = blend;

              // mask: bruk logoens alfa (no-repeat/contain/center tas av CSS-klassen)
              overlay.style.webkitMaskImage = `url("${url}")`;
              overlay.style.maskImage = `url("${url}")`;

              wrap.appendChild(overlay);
            }

            root.appendChild(wrap);
          }
        }

        function render() {
          const mode = state.cfg?.mode || "daily";
          if (mode === "clock") applyClock();
          else applyCountdown();
        }
        async function pollConfig() {
          try {
            const r = await fetch("/api/config", { cache: "no-store" });
            if (!r.ok) return;
            const js = await r.json();
            const cfg = js.config || {};
            const rev = cfg._updated_at || 0;
            if (rev !== state.lastCfgRev) {
              state.cfg = cfg;
              state.lastCfgRev = rev;
              render(); // <- re-apply theme/background/posisjon/stÃ¸rrelse
            }
          } catch (_e) {}
        }

        // Heartbeat + fullskjerm auto-skjul
        function sendHeartbeat() {
          const payload = JSON.stringify({
            rev: state.lastCfgRev,
            page: "view",
          });
          if (navigator.sendBeacon) {
            const blob = new Blob([payload], { type: "application/json" });
            navigator.sendBeacon("/debug/view-heartbeat", blob);
          } else {
            fetch("/debug/view-heartbeat", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: payload,
            }).catch(() => {});
          }
        }
        setInterval(sendHeartbeat, 10000);

        // Fullscreen-hÃ¥ndtering: ikke vis knapp i fullscreen, heller ikke ved musebevegelse
        // ===== Robust fullscreen-blokk (safe guards) =====
        const fsBtn = document.getElementById("btn_fullscreen");

        function showFsBtn() {
          if (!fsBtn) return;
          if (document.fullscreenElement) return;
          fsBtn.style.display = document.fullscreenEnabled ? "inline-block" : "none";
          fsBtn.style.opacity = "1";
        }
        function hideFsBtn() {
          if (!fsBtn) return;
          if (document.fullscreenElement) return;
          if (document.fullscreenEnabled) fsBtn.style.opacity = "0";
        }

        document.addEventListener("fullscreenchange", () => {
          const on = !!document.fullscreenElement;
          document.documentElement.classList.toggle("is-fullscreen", on);
          if (fsBtn) {
            fsBtn.style.display = on ? "none" : document.fullscreenEnabled ? "inline-block" : "none";
            if (!on) fsBtn.style.opacity = "1";
          }
        });

        function bumpActivity() {
          if (document.fullscreenElement) return;
          lastActivityTs = Date.now();
          showFsBtn();
        }
        ["mousemove", "mousedown", "keydown", "touchstart"].forEach((ev) =>
          document.addEventListener(ev, bumpActivity, { passive: true }),
        );
        setInterval(() => {
          if (!document.fullscreenElement && Date.now() - lastActivityTs > 5000) hideFsBtn();
        }, 1000);

        if (fsBtn) {
          fsBtn.addEventListener("click", async () => {
            try {
              if (!document.fullscreenElement) {
                await document.documentElement.requestFullscreen();
              } else {
                await document.exitFullscreen();
              }
            } catch (e) {}
          });
          showFsBtn();
        }

        // ===== slutt fullscreen-blokk =====

        if (!isPreview) {
          firstLoad().catch(console.error);
          setInterval(pollTick, 1000);
          setInterval(pollConfig, 3000);
        }
        if (isPreview) {
          window.addEventListener("message", (ev) => {
            const d = ev.data;
            if (!d || d.type !== "preview-config" || !d.config) return;
            state.cfg = d.config; // kun visning â€“ ikke skriv til disk
            // full fallback-tick slik at applyCountdown/applyClock alltid har feltene de bruker
            state.tick = state.tick || {
              mode: d.config.mode || "clock",
              state: "idle",
              signed_display_ms: 0,
              blink: false,
              target_hhmm: null,
            };
            render();
          });
        }
      })();
    </script>
    <!-- Overlays (logo/grafikk) -->
    <div id="overlays" class="overlays" aria-hidden="true"></div>
  </body>
</html>
