<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Countdown · Visning</title>
  <link rel="stylesheet" href="/static/css/ui.css"/>
</head>
<body class="center fill">
  <button id="btn_fullscreen" class="fs-btn" title="Fullskjerm">⛶ Fullskjerm</button>

  <!-- Nedtelling -->
  <div id="view_countdown" class="center fill" style="flex-direction:column;gap:2vh;display:none">
    <div id="msgs_above" class="muted" style="display:none;text-align:center">
      <div id="msg_primary_above"></div>
      <div id="msg_secondary_above"></div>
    </div>

    <div id="digits" class="big">00:00</div>

    <div id="msgs_below" class="muted" style="display:none;text-align:center">
      <div id="msg_primary_below"></div>
      <div id="msg_secondary_below"></div>
    </div>
  </div>

  <!-- Klokke-modus -->
  <div id="view_clock" class="center fill" style="display:none;">
    <div id="clock_time" style="font-weight:800;"></div>
    <div id="clock_msgs" aria-hidden="false">
      <div id="clock_msg_primary"></div>
      <div id="clock_msg_secondary"></div>
    </div>
  </div>


  <script>
    (function(){
      const $ = (s)=>document.querySelector(s);
      const state = { cfg:null, tick:null, lastCfgRev:0, clockTimer:null };
      let lastActivityTs = Date.now();

      const fmtMMSS = ms => { const neg=ms<0?"-":""; ms=Math.abs(ms); const t=Math.floor(ms/1000), m=Math.floor(t/60), s=t%60; return `${neg}${m}:${String(s).padStart(2,"0")}`; };
      const fmtHMS  = ms => { const neg=ms<0?"-":""; ms=Math.abs(ms); const t=Math.floor(ms/1000), h=Math.floor(t/3600), r=t%3600, m=Math.floor(r/60), s=r%60; const pad=n=>String(n).padStart(2,"0"); return `${neg}${h}:${pad(m)}:${pad(s)}`; };
      const hex2rgb = h => { const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h||""); if(!m) return "0,0,0"; return `${parseInt(m[1],16)},${parseInt(m[2],16)},${parseInt(m[3],16)}`; };

      function applyDigitsSize(){
        const vw = Number(state.cfg?.theme?.digits?.size_vw ?? 14);
        $("#digits").style.fontSize = `${vw}vw`;
      }
      function applyMessageStyles(){
        const p = state.cfg?.theme?.messages?.primary   || {};
        const s = state.cfg?.theme?.messages?.secondary || {};

        // Hjelper som skriver vmin i stedet for rem
        const set = (sel, m, factor)=> {
          const el = document.querySelector(sel);
          if (!el) return;
          const base = Number(m.size_rem ?? 1.0);     // beholder dine verdier som skaleringsfaktor
          el.style.fontSize   = `${base * factor}vmin`;
          el.style.fontWeight = String(Number(m.weight ?? 400));
          el.style.color      = String(m.color ?? "#9aa4b2");
        };

        // primær litt større enn sekundær
        set("#msg_primary_above",   p, 2.0);
        set("#msg_secondary_above", s, 1.8);
        set("#msg_primary_below",   p, 2.0);
        set("#msg_secondary_below", s, 1.8);
      }

      // --- robust background-applier: solid | gradient | image (+ tint overlay) ---
      function applyThemeBackground(el, bg) {
        if (!el || !bg) return;

        // nullstill alt først
        el.style.background = "";
        el.style.backgroundColor = "";
        el.style.backgroundImage = "";
        el.style.backgroundRepeat = "";
        el.style.backgroundSize = "";
        el.style.backgroundPosition = "";

        const mode = (bg.mode || "solid").toLowerCase();

        // hjelpefunksjon: #RRGGBB + opacity -> 'rgba(r,g,b,a)'
        function hexToRgba(hex, opacity) {
          const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec((hex||"").trim());
          if (!m) return `rgba(0,0,0,${Number(opacity||0)})`;
          const r = parseInt(m[1],16), g = parseInt(m[2],16), b = parseInt(m[3],16);
          const a = Math.max(0, Math.min(1, Number(opacity||0)));
          return `rgba(${r},${g},${b},${a})`;
        }

        if (mode === "solid") {
          el.style.backgroundColor = bg?.solid?.color || "#0b0f14";
          el.style.backgroundImage = "none";
          return;
        }

        if (mode === "gradient") {
          const from  = bg?.gradient?.from || "#142033";
          const to    = bg?.gradient?.to   || "#0b0f14";
          const angle = Number(bg?.gradient?.angle_deg ?? 180);
          el.style.backgroundImage = `linear-gradient(${angle}deg, ${from}, ${to})`;
          el.style.backgroundColor = "transparent";
          el.style.backgroundRepeat = "no-repeat";
          el.style.backgroundSize = "cover";
          el.style.backgroundPosition = "center center";
          return;
        }

        if (mode === "image") {
          const url   = (bg?.image?.url || "").trim();
          const fit   = (bg?.image?.fit || "cover").toLowerCase();
          const op    = Number(bg?.image?.opacity ?? 1);
          const tintC = bg?.image?.tint?.color || null;
          const tintO = Number(bg?.image?.tint?.opacity ?? 0);

          // bygg lag: evt. tint først, så bilde
          const layers = [];
          if (tintC && tintO > 0) {
            const rgba = hexToRgba(tintC, tintO);
            layers.push(`linear-gradient(${rgba}, ${rgba})`);
          }
          if (url) layers.push(`url("${url}")`);

          if (!layers.length) {
            // ingen bilde-URL, ingen tint: fall tilbake til solid mørk bakgrunn
            el.style.backgroundColor = "#0b0f14";
            return;
          }

          el.style.backgroundImage = layers.join(", ");
          el.style.backgroundRepeat = "no-repeat, no-repeat";
          el.style.backgroundSize = (layers.length===2 ? "auto, " : "") + (fit === "contain" ? "contain" : "cover");
          el.style.backgroundPosition = "center center, center center";
          el.style.backgroundColor = "transparent";

          // ‘opacity’ på image-laget: vi simulerer ved å injisere en alfamiks,
          // men enklest: la tint håndtere “mørking”, og la image være 100%.
          // Hvis du VIL bruke ‘opacity’, gjør det via egen overlay-node (ikke nødvendig her).
          return;
        }
      }


      function applyCountdown(){
        $("#view_clock").style.display = "none";
        const root = $("#view_countdown");
        root.style.display = "flex";
        // legg tema-bakgrunn på BODY
        applyThemeBackground(document.body, state.cfg?.theme?.background);
        // cleanup clock timer hvis aktiv
        if (state.clockTimer){ clearInterval(state.clockTimer); state.clockTimer=null; }
        $("#clock_time").style.display="none";

        applyDigitsSize(); applyMessageStyles();

        const c=state.cfg, t=state.tick;
        const thresholdMs=(c.hms_threshold_minutes??60)*60*1000;
        const msActive=(t.state==="countdown"||t.state==="overrun");
        const ms = msActive ? t.signed_display_ms : 0;

        const useHMS = Math.abs(ms) >= thresholdMs;
        const digits = $("#digits");
        digits.textContent = useHMS ? fmtHMS(ms) : fmtMMSS(ms);

        let color = c.color_normal;
        if (c.use_phase_colors) {
          if (t.state === "overrun" || t.signed_display_ms < 0) color = c.color_over || c.color_alert;
          else if (t.mode === "alert") color = c.color_alert;
          else if (t.mode === "warn")  color = c.color_warn;
        }
        digits.style.color = color;
        digits.classList.toggle("blink", !!(c.use_blink && t.blink));

        const targetTextPrim = (c.show_target_time && c.show_message_primary   && c.target_time_after === "primary"   && t.target_hhmm) ? ` ${t.target_hhmm}` : "";
        const targetTextSec  = (c.show_target_time && c.show_message_secondary && c.target_time_after === "secondary" && t.target_hhmm) ? ` ${t.target_hhmm}` : "";

        const prim = c.show_message_primary   ? ((c.message_primary   || "") + targetTextPrim) : "";
        const sec  = c.show_message_secondary ? ((c.message_secondary || "") + targetTextSec ) : "";

        const above = c.messages_position === "above";
        $("#msgs_above").style.display = above ? "block" : "none";
        $("#msgs_below").style.display = above ? "none"  : "block";
        $("#msg_primary_above").textContent   = above ? prim : "";
        $("#msg_secondary_above").textContent = above ? sec  : "";
        $("#msg_primary_below").textContent   = !above ? prim : "";
        $("#msg_secondary_below").textContent = !above ? sec  : "";
      }

      function applyClock(){
        // Skjul nedtelling
        const viewCountdown = $("#view_countdown");
        if (viewCountdown) viewCountdown.style.display = "none";

        // DOM
        const root = document.querySelector("#view_clock, #view_screen");
        const clkEl = document.querySelector("#clock_time, #screen_clock");
        const wrap = $("#clock_msgs");
        const elP  = $("#clock_msg_primary");
        const elS  = $("#clock_msg_secondary");
        if (!root || !clkEl || !wrap || !elP || !elS) return;

        root.style.display = "flex";

        // litt luft mot sidene
        const SIDE_INSET_VW = 5, TOP_BOTTOM_VH = 3;
        root.style.padding = `${TOP_BOTTOM_VH}vh ${SIDE_INSET_VW}vw`;

        // Bakgrunn
        applyThemeBackground(document.body, state.cfg?.theme?.background);

        // Klokkens plassering
        const clockPos = (state.cfg?.clock?.position || "center").toLowerCase();
        const posMap = {
          "center":        { ai: "center",     jc: "center"     },
          "top-left":      { ai: "flex-start", jc: "flex-start" },
          "top-right":     { ai: "flex-start", jc: "flex-end"   },
          "bottom-left":   { ai: "flex-end",   jc: "flex-start" },
          "bottom-right":  { ai: "flex-end",   jc: "flex-end"   },
          "top-center":    { ai: "flex-start", jc: "center"     },
          "bottom-center": { ai: "flex-end",   jc: "center"     }
        };
        const m = posMap[clockPos] || posMap.center;
        root.style.alignItems = m.ai;
        root.style.justifyContent = m.jc;

        // Klokkens typografi
        const clk = state.cfg?.clock || {};
        const sizeVmin = Number(clk.size_vmin ?? clk.size_vh ?? 12);
        const size = Math.max(6, Math.min(30, sizeVmin));
        clkEl.style.fontSize = `${size}vmin`;
        clkEl.style.fontWeight = "800";
        clkEl.style.display = "block";
        clkEl.style.color = clk.color || "#e6edf3";

        // Meldinger: vis KUN hvis use_clock_messages = true
        const useOwn = !!clk.use_clock_messages;
        if (!useOwn) {
          wrap.style.display = "none";
        } else {
          const msgP  = (clk.message_primary   || "").trim();
          const msgS  = (clk.message_secondary || "").trim();
          const showP = !!msgP;
          const showS = !!msgS;

          // plassering rundt klokka
          const msgPos   = (clk.messages_position || "right");   // right|left|above|below
          const msgAlign = (clk.messages_align    || "center");  // start|center|end

          if (msgPos === "left" || msgPos === "right") {
            root.style.flexDirection = "row";
            wrap.style.flexDirection = "column";
            clkEl.style.order = (msgPos === "left") ? 2 : 1;
            wrap.style.order  = (msgPos === "left") ? 1 : 2;

            // 👉 mer luft mellom klokke og tekst
            root.style.gap = "3vmin";
            // ekstra side-margin for wrap slik at det ikke “klistrer” seg til klokka
            wrap.style.marginLeft  = (msgPos === "right") ? "2vmin" : "0";
            wrap.style.marginRight = (msgPos === "left")  ? "2vmin" : "0";
          } else {
            root.style.flexDirection = "column";
            clkEl.style.order = (msgPos === "above") ? 2 : 1;
            wrap.style.order  = (msgPos === "above") ? 1 : 2;
            wrap.style.flexDirection = "column";

            // vertikal layout – litt mindre gap
            root.style.gap = "1.25vmin";
            wrap.style.marginLeft = wrap.style.marginRight = "0";
          }

          wrap.style.display = (showP || showS) ? "flex" : "none";
          wrap.style.alignItems = ({"start":"flex-start","center":"center","end":"flex-end"}[msgAlign] || "center");
          wrap.style.textAlign  = ({"start":"left","center":"center","end":"right"}[msgAlign] || "center");
          wrap.style.gap = "0.25rem";

          elP.style.display = showP ? "block" : "none";
          elS.style.display = showS ? "block" : "none";

          elP.textContent = msgP;
          elS.textContent = msgS;

          // ✨ Skaler tekst i vmin (pkt. 2)
          const themeMsg = state.cfg?.theme?.messages || {};
          const pTheme = themeMsg.primary   || {};
          const sTheme = themeMsg.secondary || {};
          elP.style.fontSize   = `${Number(pTheme.size_rem ?? 1.0) * 2.0}vmin`;
          elP.style.fontWeight = String(pTheme.weight ?? 600);
          elP.style.color      = String(pTheme.color ?? "#9aa4b2");
          elS.style.fontSize   = `${Number(sTheme.size_rem ?? 1.0) * 1.8}vmin`;
          elS.style.fontWeight = String(sTheme.weight ?? 400);
          elS.style.color      = String(sTheme.color ?? "#9aa4b2");
        }

        // Timer
        if (state.clockTimer) { clearInterval(state.clockTimer); state.clockTimer = null; }
        const update = () => {
          const d = new Date();
          const HH = String(d.getHours()).padStart(2,"0");
          const MM = String(d.getMinutes()).padStart(2,"0");
          const SS = String(d.getSeconds()).padStart(2,"0");
          clkEl.textContent = clk.with_seconds ? `${HH}:${MM}:${SS}` : `${HH}:${MM}`;
        };
        update();
        state.clockTimer = setInterval(update, clk.with_seconds ? 1000 : 5000);
      }

      async function fetchConfig(){
        const r = await fetch("/api/config"); const js = await r.json();
        state.cfg = js.config; state.lastCfgRev = js.config._updated_at || 0;
        sendHeartbeat();
      }
      async function firstLoad(){
        await fetchConfig();
        const r = await fetch("/tick"); state.tick = await r.json();
        render();
        sendHeartbeat();
      }
      async function pollTick(){
        const r = await fetch("/tick"); const t = await r.json();
        state.tick = t;
        if ((t.cfg_rev||0) !== state.lastCfgRev) await fetchConfig();
        render(true);
      }

      function render(){
        const mode = (state.cfg?.mode) || "daily";
        if (mode === "clock") applyClock(); else applyCountdown();
      }
      async function pollConfig(){
        try{
          const r = await fetch("/api/config", { cache: "no-store" });
          if (!r.ok) return;
          const js = await r.json();
          const cfg = js.config || {};
          const rev = cfg._updated_at || 0;
          if (rev !== state.lastCfgRev) {
            state.cfg = cfg;
            state.lastCfgRev = rev;
            render(); // <- re-apply theme/background/posisjon/størrelse
          }
        }catch(_e){}
      }


      // Heartbeat + fullskjerm auto-skjul
      function sendHeartbeat(){
        const payload = JSON.stringify({ rev: state.lastCfgRev, page: "view" });
        if (navigator.sendBeacon) {
          const blob = new Blob([payload], {type: "application/json"});
          navigator.sendBeacon("/debug/view-heartbeat", blob);
        } else {
          fetch("/debug/view-heartbeat",{method:"POST",headers:{"Content-Type":"application/json"},body:payload}).catch(()=>{});
        }
      }
      setInterval(sendHeartbeat, 10000);

      // Fullscreen-håndtering: ikke vis knapp i fullscreen, heller ikke ved musebevegelse
      // ===== Robust fullscreen-blokk (safe guards) =====
  const fsBtn = document.getElementById("btn_fullscreen");

  function showFsBtn(){
    if (!fsBtn) return;
    if (document.fullscreenElement) return;
    fsBtn.style.display = (document.fullscreenEnabled ? "inline-block" : "none");
    fsBtn.style.opacity = "1";
  }
  function hideFsBtn(){
    if (!fsBtn) return;
    if (document.fullscreenElement) return;
    if (document.fullscreenEnabled) fsBtn.style.opacity = "0";
  }

  document.addEventListener("fullscreenchange", () => {
    const on = !!document.fullscreenElement;
    document.documentElement.classList.toggle("is-fullscreen", on);
    if (fsBtn) {
      fsBtn.style.display = on ? "none" : (document.fullscreenEnabled ? "inline-block" : "none");
      if (!on) fsBtn.style.opacity = "1";
    }
  });

  function bumpActivity(){
    if (document.fullscreenElement) return;
    lastActivityTs = Date.now();
    showFsBtn();
  }
  ["mousemove","mousedown","keydown","touchstart"].forEach(ev =>
    document.addEventListener(ev, bumpActivity, { passive:true })
  );
  setInterval(()=>{ if (!document.fullscreenElement && Date.now()-lastActivityTs > 5000) hideFsBtn(); }, 1000);

  if (fsBtn) {
    fsBtn.addEventListener("click", async () => {
      try {
        if (!document.fullscreenElement) {
          await document.documentElement.requestFullscreen();
        } else {
          await document.exitFullscreen();
        }
      } catch (e) {}
    });
    showFsBtn();
  }
  // ===== slutt fullscreen-blokk =====

      firstLoad().catch(console.error);
      setInterval(pollTick, 1000);
      setInterval(pollConfig, 3000);  // sørger for at theme/background oppdateres uten refresh
    })();
  </script>
</body>
</html>
